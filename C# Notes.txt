--------------------------------------------------[Create Console Project] --------------------------------------------------
	- Bash => dotnet new console 	// [console, mvc, webapi, ...] [-o output, -n name, ...]
	- bash => dotnet run			// to run the project
	- bash => dotnet build          // build the application
	- bash => dotnet restore 		// install the necessary  
	
[Comments]
	- //							// Single Line Comment	
	- /* */                         // Multiple Line Comment
	- ///							// XML Comment 
	
-------------------------------------------------- [Data Tpyes] --------------------------------------------------
	
	- [ Integral Types ]
		- byte / sbyte		=> 8bit			
		- short / ushort	=> 16bit	=> System.Int16		//.Net Type
		- int / uint		=> 32bit    => System.Int32     //.NET Type
		- long / ulong		=> 64bit	=> System.Int64		//.NET Type
		
	- [ Floating-Point ]
		- float 			=> 32bit		0.1f			=> System.Single			
		- double 			=> 64bit		0.1				=> System.Double
		- decimal 			=> 128bit		0.1m			=> System.Decimal
		
	- [ Character ]
		- Char 				=> 16bit	=> System.Char
		
	- [ String ]
		- String 			=> 16bit/char	=> System.String
	
	- [ Boolean ]
		- bool				=> 1bit	=> true/false			=> System.Boolean
				
	- [ Date ]		
		- DateTime			=> 8bit							=> System.DateTime
		- DateTime date = DateTime.now;
		
	- [ Object ]
		- var person = new { name = "John", age = 25 };		// Anonymous types
		- Person person = new Person("john", 25);			// Instance from a Class Person
		- dynamic obj = new System.Dynamic.ExpanoObject();	obj.name = "John"; Console.WriteLine(obj.name);	// Dynamic Object
	
	- [ Nullable ]
		- [primitive] + [?]	=> allow null

	- [ Enumerations ]
		- enum 				=> value type that defines a set of named integral constants
		- enum Days {sat, sun, mon = 5, tues, }		// int x = (int)Days.sun;
		
	- [ Arrays ]
		- int[] data = {2,3,5} | new int[] {2,3,5} | new int[3] {2,3,5}
		
	- [ Structs ]
		- public struct Person { 
			public string name;
			public int age;   									                       
			public Person(){this.name = "John"; this.age = 25;}					// Constructor
			public void DisplayInfo(){ Conole.Writeline($"{name} {age}") }		// Methods
		}
	
	- [ Classes ] 	--------------------------------------------------
		- Members:		Fields, Methods, Properties(get, set), Constructor
		- Constructor: 	[ Default, Parameterized, DeepCopy, ShallowCopy, Static]
		- [ Parent Class(base) | Child Class(derived) | Abstract Class | Sealed Class | Static Class | Partial Class | Generic Class | Container Class ]
		- [ Singleton Class | Factory Class | Immutable Class | DTO Class | Attribute Class | Disposal Class |   ]
		
	- [ Interfaces ] 	--------------------------------------------------
		- public interface IMovable{ void Draw(); int X {get; set;} }
	
	- [ Other Types ]
		- dynamic 			=> Represents an object whose operations are resolved at runtime
		- var				=> Implicitly-typed variable, the type is inferred by the compiler
		
-------------------------------------------------- [ Operators ] --------------------------------------------------

	- Arithmetic Operators: 		=> [+, -, /, *, %]  
	
	- Comparison Operators: 		=> [==, !=, <, >, <=, >=]   
	
	- Logical Operators: 			=> [&&, ||, !]              
	
	- Assignment Operators: 		=> [=, +=, -=, *=, /=, %=]  
	
	- Inc and Dec Operators: 		=> [++, --]  
	
	- Bitwise Operators: 		=> [&, |, ^, ~, <<, >>]
		
-------------------------------------------------- [ Implicit / Explicit Conversions ] --------------------------------------------------
	- Implicit Conversion is done by the compiler if there is no data will be lost like:
		int x = 5;	double y = x;			// here x implicitly converted into double => no data loss
		
	- Explicit Conversion is done manually and need a cast to force it like:
		double x = 3.3; 	int y = (int)x;		// We have to cast the value as an int
		
-------------------------------------------------- [Built-In Methods] --------------------------------------------------

	- [String Class Methods]
		- .Length | [indexing] | .Substring() | .Concat | .Equals | .Compare | .ToLower
		  .ToUpper | .Trim | .Contains | .IndexOf | .LastIndexOf | .Replace | .Split
	
	- [Math Class Methods]
		- Math.[Add, Subtact, Multiply, Divide, Pow, Sin, Cos, Tan, PI, Log, Log10, Sqrt, Round, Ceiling, Floor, Abs]
	
	- [Array Methods]
		- .Length | [Indexing] | .CopyTo | .Clone | .Sort | .BinarySearch | .Fill | .Reverse | .Clear | .Equals | .ToList() | .Copy
		- int[,] matrix;
		- int[][] jaggedArray;
	
	- [Type Conversion Methods]
		- implicit / explicit (casting)
		- Convert.ToInt[16/32/64] | .ToString | int.Parse | int.TryParse 
		- [Boxing & UnBoxing]
			- [Boxing] 
				- ValueType 			=> 	ReferenceType
				- int intvalue = 42;		object BoxedValue = intvalue;
				
			- [Unboxing]
				- ReferenceType			=> 	ValueType
				- object BoxedValue = 42;   int intValue = (int)BoxedValue;
			
			- [Performance Considerations]
				- (memory allocation) new object is created in the heap and the reference to that object stored in the stack
				- (Copying) Copy the value type from the stack, which introduces overhead especially for larger value types
				- (Type-Checking Overhead) when unboxing a value from an object there's a need for type-checking to ensure that the object actually contains a value of the expected type
				
		- [explicit operator]
			- public static explicit operator double(myObject value){ return value.weight; }
			// User-defined explicit conversion operator which convert an instance from a class to a double
			
	- [Linq Methods]
		- Where | Select | OrderBy | OrderByDescending | GroupBy | Join | GroupJoin | Take | Skip
		- First | FirstOrDefault | Single | SingleOrDefault | Last | LastOrDefault | Any | All | Aggregate
		- Count | Sum | Min | Max | Average | Concat | Distinct | Union | Intersect | Except | AsQueryable
		- Reverse | AsEnumerable | ToArray | ToList | ToDictionary | OfType | Cast | ToLookup | Skip | Take 
	
	- [IO Methods] (using System.IO;)
		
		- [File Class]
			- File.ReadAllText("") 			=> Returns string
			- FileInfo("")					=> Returns FileInfo 
			- File.[Exists | Copy | Delete | Move | ReadAllLines | ReadAllBytes | WriteAllText | AppendTet | OpenRead | OpenWrite]
		
		- [Directory Class]
			- Directory.GetFiles("") 		=> Returns string[]
			- DirectoryInfo("")				=> Returns DirectoryInfo
			- Directory.[Exists | CreateDirectory | GetFiles | GetDirectories | GetParent | Move | Delete | GetLogicaldrives | GetCreationTime | GetLastAccessTime | GetLastWriteTime]
		
		- [Path Class]
			- Path.[Combine() | GetExtension | GetFileName | GetDirectoryName | GetFullPath | GetPathRoot | GetRandomFileName | IsPathRooted | ChangeExtension | GetTempFileName | GetTempPath ]
			
		- [FileStream Class]
			- FileStream fs = new FileStream("",FileMode.Open)	
			- fs.[Read | Write | Seek | Length | Flush | Close | Dispose | CanRead | CanWrite | CanSeek | Position ]
		
	- [Miscellaneous]
		
		- [Random Class]
			- Random random = new Random()
			- random.[ Next | NextDouble | NextByte(new byte[10]) | Convert.ToBase64String(new byte[10]) => string ]
			
		- [Convert Class]
			- Convert.[ ToBoolean | ToByte | ToInt32 | ToSingle | ToDouble | ToString | ToDateTime | ToChar | ChangeType ]
		
		- [DateTime & TimeSpan Classes]
			- DateTime.[Now | Today | UtcNow | Parse | TryParse | TopString("yyyy-MM-dd HH:mm:ss") | AddDays | Now.Subtract | Compare | Now.DayOfWeek | IsLeapYear ]
			- TimeSpan.[FromSeconds | FromMInutes | FromHours | Parse(time) | Compare |  ]
			- time.[Add | Subtract | TotalSeconds | TotalHours | TotalMinutes | ToString() | Equals(time2) | Zero ]

		- [Console Class]
			- Console.[Write | WriteLine | Read | Readline | ReadKey | Beep | Title | WindowWidth | WindowHeight | BufferWidth | BufferHeight ]
		
		- [Environment Class]
			- Environment.[GetCommandLineArgs | CurrentDirectoruy | Exit | GetFolderPath | MachineName | OSVersion | StackTrace | SystemDirectory | TickCount | TickCount64 | UserDomainName | userName | Version | WorkingSet]
		
--------------------------------------------------  [WorkFlow] --------------------------------------------------
	- [Sequential Execution]
		- Statements are executed one after the other in the order they appear in the code 
		
	- [Selection Statements]
		- if - else
		- switch
	
	- [Repetition Statements]
		- for					=> Number of Iteration is knew
		- wihle					=> Unknown number of iteration and continues looping until the condition change
		- do-while				=> Same as while but to ensure that the body executed at least once
		- foreach-in			=> Looping over Collections like Arrays, Lists, etc...
	
	- [Jump Statements]
		- break
		- continue
		- return
		- goto
		
	- [Exception Handling]
		- try-catch-finally
		- try{}catch(){}catch(){}finally{}
		- Use cases for finally [Cleanup Operations | Guaranteed Execution | Resource Deallocation]


	- [Functions & Methods]
		- Function is a self-contained unit of code that performs a specific task
			[AccessModifier] [ReturnType] [FunctionName]([Params]){[body]}
		- Method is a function but associated with an object or a class (a member of a class)
		- Arrow function like: public ind Add(int a, int b) => a + b;


-------------------------------------------------- [Generics] --------------------------------------------------
	- Writing a code that can work with any data type.
	- We can use Generic method in non-generic class
	- [Generic Class & Method]
		//Generic Class
		public Class GenericClass<T>
		{
			private T genericField;
			public GenericClass(T vlaue){
				GenericField = value;
			}
			//Generic Method
			public T GetValue(){
				return genericField;
			}
		}
		Genericclass<int> data = new GenericClass<int>(3);
		
	- [Generic Interfaces and Delegates]
		- public interface IGenericInterface<T>{ T GetValue(); }
		- public delegate void GenericDelegate<T>(T argument) 
		
	- [Constriants]
		- Used with Generic types to specify the capabilities or characteristics that the type parameter must have 
			- where T : class				// Ensures that the type argument is a reference type (class)
			- where T : struct				// Ensures that the type argument is a value type (struct)
			- where T : new()				// Ensures that the type argument has a parameterless constructor
			- where T : myBaseClass			// Ensures that the type argument must be or derive from a specific base class 
			- where T : IMyInterface		// Ensures that the type argument implements a specific interface
			- where T : U					// Ensures that the type argument must be or derive from the type specified by U
			- where T : notnull        		// Ensures that the type argument is non-nullable reference or non-nullable value
		- Use benefits => [ Type Safety | Reusability | Avoid Reflection | Prevent Nullability | Readability and Intent ]
		- public class Employee(): Person, IWorkable, 
	
-------------------------------------------------- [Delegate] --------------------------------------------------
	- A type which represents references to methods with a particular parameter list and return type
      - Pass a function as a parameter to another function
      - Create new delegate 
            - public delegate void MyDelegate(string message)           // A Reference Type which match only the methods that returns void and take string as a parameter 
                                                                                                           // MyDelegate is a type not an instance
      - Create Instance from the delegate
            - MyDelegate print = (a) => Console.WriteLine(a);             // Create an Instance(print) from MyDelegate Delegate and                                   
	
      
	- public delegate void MyDelegate(string message);	            // Delegate Creation, Assignable with methods void return type and takes string as a parameter 
	- public class MyClass{                                                                   
		public void MyMethod(string message){				      // We will assign the reference of that method to a variable of MyDelegate Type
			Console.WriteLine(message);
		}
	}
	- MyClass obj = new MyClass();								// Create Instance from the class MyClass to use Its method
	- MyDelegate d = obj.MyMethod;								// Assign the reference of the method to the newly created 
	// now I can pass it to a function or invoke it 
	
	- [ Multicasting ]
		- Delegates support multicastin, which means you can combine multiple methods into a single delegate
		d += obj.someOtherMethod
		d();
		
	[ Delegates Built-In ]
	
		- [ Func ] 
			- Represents a function that returns value and takes values		T1 <= T2, T3, ...
			- Func<int, int, int> add = (a,b) => a+b;	int result = add(3,5);
			
		- [ Action ]
			- Represents a method returns void and takes parameters		void <= T1, T2, ...
			- Action<string,string> print = (a,b) => Console.WriteLine(a+b);
			
		- [ Predicate ]
			- Represents a method return boolean and takes parameters		bool <= T1
			- Predicate<int> isbigger = (a) => a <= 6;	isbigger(3);		// Takes only one argument
                  
          [Anonymous delegate]
                    - A reference who have no name its reference not stored in the stack
                    - prin(delegate (int num) {return num>5})       // one use only, when we need a function just for one time, we don't create it
                    - Anonymous is not a better use instead we use Lambda Expression
                    - print(delegate (int num) { return num>5 })                   =>                  print(num => num > 5)
			
-------------------------------------------------- [ Event ] --------------------------------------------------
	- [ Observer design Pattern ]
                    - Simulating the Event Concept with that
                    
		- Publisher (Subject)
			- This is the entity that holds the information, notifies observers(listeners) about changes [WebSite, News]
		
		- Listeners (Observer)
			- These are the entities interested in being notified when the publisher changes [Users]
		
		- Subscription
			- This is the mechanism that connects the publisher and the listeners
          
          - There are issues using delegates
                    - assign delegate to null remove all the methods 
                    - any one can call it and it must be public so let the listeners subscibe
                    - Listener can assign more that one method
                    
          - To solve these 
                    - we have to disallow the listener to control the publisher => we use 'event' keyword
                    - by using event we can only use -= and +=. We can't use = so we can't assign null to it
          
          
		
		
		
		
		
		
	
	
		
		
	
	
	
	
	
	



	
	
	
	
	
	
	
	